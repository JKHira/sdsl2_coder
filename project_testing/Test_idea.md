以下は、**「3つのシステムで1つの処理を完結させる」**前提で、実験用に最小構成で描いた大まかなトポロジー案です。身近で分かりやすい題材として、**ECサイトの注文処理（在庫引当→決済→出荷依頼）**を選びます。
（狙い：あとから L0/L1/L2 のような段階ゲートや整合性検査を差し込みやすい、現実的な典型構造にする）

⸻

実験用構想：注文処理を3システムで完結させる

0. 何を「処理」として成立させるか

本構想が成立していると見なす「完了条件」は次の通りです。
	•	ユーザーが注文を確定すると、注文が記録される
	•	在庫が引当できた場合のみ決済が行われる
	•	決済が成功した注文のみ出荷依頼が作成される
	•	失敗時は、整合性の取れる状態に必ず戻る（在庫・決済・注文状態が矛盾しない）

これを、以下の3システムで実現します。
	1.	S1: Order API（注文フロント／注文台帳）
	2.	S2: Inventory Service（在庫引当）
	3.	S3: Payment & Fulfillment Service（決済＋出荷依頼）

“Payment と Fulfillment を同一システムにまとめる”ことで、ちょうど3システムに収めます。

⸻

1) 全体トポロジー（俯瞰）

ネットワーク境界と主要経路
	•	外部（ユーザー／ブラウザ／アプリ）から入る入口は S1 のみ
	•	S1 は内部ネットワークで S2・S3 を呼ぶ
	•	イベントやキューを使う場合も、3システムの内部コンポーネントとして内包する（外部の第4システム扱いにしない）

俯瞰図（概念）
	•	外部クライアント
→ S1: Order API
→（在庫引当 요청）→ S2: Inventory
→（決済＋出荷 요청）→ S3: Payment & Fulfillment
→（結果戻し）→ S1: Order API

⸻

2) システム別トポロジー（大まかな内部構造）

S1: Order API（注文フロント／注文台帳）

役割
	•	外部からの注文確定リクエストを受ける
	•	注文の状態遷移を一元管理する（注文台帳が真実の源泉）
	•	S2/S3 との統合のハブになる

主な内部コンポーネント
	•	API Gateway / Web Handler：外部入力の受付、認証、レート制限
	•	Order Orchestrator：注文処理の進行（引当→決済→出荷）を管理
	•	Order DB：注文の永続化（状態・金額・明細・関連ID）
	•	Outbox（任意）：後段に渡す確定イベントを確実に配る仕組み
※実験では“同期呼び出し中心”でもよいが、将来の拡張点として想定

S1が持つ「真実」
	•	注文状態（例：NEW / RESERVED / PAID / FULFILLMENT_CREATED / FAILED）
	•	取引の相関ID（注文ID、在庫予約ID、決済ID、出荷依頼ID）

⸻

S2: Inventory Service（在庫引当）

役割
	•	在庫の引当（予約）と解放を行う
	•	同じ注文に対する二重引当を防ぐ
	•	在庫の整合性（数量が負にならない）を守る

主な内部コンポーネント
	•	Reserve API：在庫予約（引当）
	•	Release API：予約解放（キャンセル・失敗補償）
	•	Inventory DB：SKUごとの利用可能数、予約数、予約レコード
	•	Consistency Guard：同時更新の競合を抑える（楽観ロック／行ロック相当の概念）

S2が持つ「真実」
	•	SKUの可用在庫
	•	予約（reservation）レコード
（注文IDに紐づく予約ID、期限、数量、状態）

⸻

S3: Payment & Fulfillment Service（決済＋出荷依頼）

役割
	•	決済を実行し、成功したら出荷依頼を作る
	•	失敗時に「決済だけ成功／出荷だけ失敗」のような中途半端な状態を避ける
	•	外部決済手段（カード会社等）がある想定でも、S3が境界で吸収する

主な内部コンポーネント
	•	Payment API：決済実行、決済結果照会
	•	Fulfillment API：出荷依頼作成
	•	Payment DB：決済トランザクションの記録（冪等キー含む）
	•	Fulfillment DB：出荷依頼の記録
	•	Idempotency Store：同一注文への重複決済や重複出荷依頼を防ぐ

S3が持つ「真実」
	•	決済の確定状態（成功／失敗／不明）
	•	出荷依頼の確定状態（作成済／未作成）

⸻

3) データフロー（処理の時系列トポロジー）

正常系フロー（同期オーケストレーション型）
	1.	ユーザー → S1：注文確定（カート明細、配送先、支払手段トークン等）
	2.	S1：Order DB に注文 NEW を作成
	3.	S1 → S2：在庫予約（注文ID、SKU、数量）
	4.	S2：在庫が足りれば予約IDを返す（RESERVED）
	5.	S1：注文状態を RESERVED に更新（予約IDも記録）
	6.	S1 → S3：決済＋出荷依頼（注文ID、金額、予約ID、配送先）
	7.	S3：決済成功 → 出荷依頼作成 → 決済ID・出荷依頼IDを返す
	8.	S1：注文状態を FULFILLMENT_CREATED（または PAID→FULFILLMENT_CREATED）に更新
	9.	完了レスポンスをユーザーへ返却

この形にすると、責務の境界が明確で、統合テストもしやすいです。

⸻

失敗系と補償（矛盾が起きやすい箇所）

実運用で揉めやすいのは「途中で落ちたとき、何が真実か」です。そこで、意図的に“矛盾しやすい点”を明確にしておきます。

失敗点A：在庫予約は成功したが、S1が注文状態更新前に落ちた
	•	S2には予約が残る
	•	S1の注文は NEW のまま
対策（設計方針）：
	•	S2予約には期限（TTL）を持たせ、期限切れで自動解放
	•	S1は再試行時に「同一注文IDの予約が既にあるか」を確認できる照会を用意する（あるいはReserveを冪等にする）

失敗点B：決済は成功したが、出荷依頼作成が失敗した
	•	S3内で整合性が崩れるリスク
対策：
	•	S3内部は「決済成功＝必ず出荷依頼が作られる」ように、同一トランザクションとして扱う（難しければ、決済成功後に出荷依頼を再試行するジョブをS3内に持つ）
	•	S1はS3から返る状態を鵜呑みにせず、照会可能にする

失敗点C：S3成功後にS1が落ち、注文が更新されない
	•	S3には決済・出荷依頼があるのに、S1は RESERVED のまま
対策：
	•	S1が再実行時に S3へ照会し、状態を回復できる（リカバリパス）
	•	あるいは S3→S1 へ完了通知（イベント）を返す（ただし“第4システム化”しないようS1内の受信口として設計）

⸻

4) インターフェース（契約の最小セット）

実験用途として最低限、次のインターフェースがあれば統合の穴が露呈します。

S1 ↔ S2
	•	ReserveInventory（注文ID、SKU、数量）→（予約ID or 在庫不足）
	•	ReleaseInventory（予約ID）→（解放成功）
	•	GetReservation（予約ID or 注文ID）→（予約状態）

S1 ↔ S3
	•	PayAndCreateFulfillment（注文ID、金額、予約ID、配送先、冪等キー）→（決済ID、出荷依頼ID）
	•	GetPaymentStatus（注文ID or 決済ID）
	•	GetFulfillmentStatus（注文ID or 出荷依頼ID）

ここでの重要点は、照会系APIを必須にすることです。
同期フローが途中で落ちたとき、「再実行で状態を回復できるか」が、統合の成否を左右します。

⸻

5) トポロジーとしての“設計上の論点”（揉める・穴になりやすい点）

実験用でも、ここを曖昧にするとすぐ破綻します。

5.1 どこがSSOTか（真実の源泉の定義）
	•	注文の最終状態は S1（Order DB）
	•	在庫の真実は S2
	•	決済と出荷依頼の真実は S3
ただし、S1がユーザー向けの集約ビューを持つので、S1が各システムの状態を参照して整合させる責務を持つ

5.2 冪等性の境界
	•	S1は「同一注文IDで二重に処理を走らせても壊れない」必要がある
	•	S2の予約は「同一注文ID＋SKU＋数量」で冪等にできるのが望ましい
	•	S3は「同一注文ID＋冪等キー」で重複決済を防ぐのが必須

5.3 タイムアウトと再試行の設計
	•	S1がS2/S3を同期呼び出しすると、タイムアウト時に「結果が成功だったか不明」が頻発する
→ だから照会APIが必要
→ さらに冪等性が必要

5.4 監査・観測（運用で詰まるポイント）
	•	3システムのログを相関ID（注文ID）で追えること
	•	「この注文はいまどこで止まっているか」をS1が説明できること
（NEWのまま／予約あり／決済済み／出荷待ち 等）

⸻

6) 実験としての“検査観点”（この構想で何が検証できるか）

この3システム構成は、次の検査がしやすいです。
	•	正常系が最後まで通るか（在庫→決済→出荷）
	•	失敗点A/B/Cで、矛盾状態が残らないか
	•	冪等性が成立しているか（連打、リトライ、二重送信）
	•	「照会により回復」できるか（S1が落ちた後に再実行）
	•	仕様上の曖昧さ（SSOT、優先順位、タイムアウト時の扱い）が露呈するか

⸻

まとめ（この案の価値）
	•	3システムという最小の現実構成で、統合の主要な地雷（冪等性、SSOT、補償、回復、観測）を全部踏めます。
	•	追加の外部基盤（メッセージング等）を“第4システム”として切り出さずに、内部コンポーネントとして扱えるため、実験のスコープが保てます。

⸻

必要なら次に、この同じ題材で「もう少し違うタイプ」のトポロジー（例：社内ワークフロー承認、給与計算、勤怠締め、またはチケット購入）を、同じく3システム縛りで追加提案できます。